<!DOCTYPE html>
<html lang="zh_CN" data-theme-mode="light" data-light-theme="Savor" data-dark-theme="Dark+">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"/>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes"/>
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="stylesheet" type="text/css" id="baseStyle" href="stage/build/export/base.css?2.8.7"/>
    <link rel="stylesheet" type="text/css" id="themeDefaultStyle" href="appearance/themes/Savor/theme.css?2.8.7"/>
    <link rel="stylesheet" type="text/css" id="themeStyle" href="appearance/themes/Savor/theme.css?2.8.7"/>
    <title>D:\3D\顺序容器 - 思源笔记  v2.8.7</title>
    <style>
        body {background-color: var(--b3-theme-background);color: var(--b3-theme-on-background)}
        .b3-typography, .protyle-wysiwyg, .protyle-title {font-size:16px !important}
.b3-typography code:not(.hljs), .protyle-wysiwyg span[data-type~=code] { font-variant-ligatures: none }
.li > .protyle-action {height:34px;line-height: 34px}
.protyle-wysiwyg [data-node-id].li > .protyle-action ~ .h1, .protyle-wysiwyg [data-node-id].li > .protyle-action ~ .h2, .protyle-wysiwyg [data-node-id].li > .protyle-action ~ .h3, .protyle-wysiwyg [data-node-id].li > .protyle-action ~ .h4, .protyle-wysiwyg [data-node-id].li > .protyle-action ~ .h5, .protyle-wysiwyg [data-node-id].li > .protyle-action ~ .h6 {line-height:34px;}
.protyle-wysiwyg [data-node-id].li > .protyle-action:after {height: 16px;width: 16px;margin:-8px 0 0 -8px}
.protyle-wysiwyg [data-node-id].li > .protyle-action svg {height: 14px}
.protyle-wysiwyg [data-node-id] [spellcheck] {min-height:26px;}
.protyle-wysiwyg [data-node-id] {}
.protyle-wysiwyg .li {min-height:34px}
.protyle-gutters button svg {height:26px}
.protyle-wysiwyg img.emoji, .b3-typography img.emoji {width:18px}
.protyle-wysiwyg .h1 img.emoji, .b3-typography h1 img.emoji {width:35px}
.protyle-wysiwyg .h2 img.emoji, .b3-typography h2 img.emoji {width:31px}
.protyle-wysiwyg .h3 img.emoji, .b3-typography h3 img.emoji {width:27px}
.protyle-wysiwyg .h4 img.emoji, .b3-typography h4 img.emoji {width:25px}
.protyle-wysiwyg .h5 img.emoji, .b3-typography h5 img.emoji {width:22px}
.protyle-wysiwyg .h6 img.emoji, .b3-typography h6 img.emoji {width:20px}
    </style>
</head>
<body>
<div class="b3-typography" style="max-width: 800px;margin: 0 auto;" id="preview"><h1 id="顺序容器" updated="20230515190114">顺序容器</h1>
<h2 id="概述" updated="20230515190114">概述</h2>
<p id="20230515190114-rkyq2ym" updated="20230515190114"><span data-type="strong" style="color: var(--b3-font-color12);">类型</span></p>
<ul id="20230515190114-oiohq4e" updated="20230515190114">
<li id="20230515190114-q4jrrwp" updated="20230515190114">
<p id="20230515190114-hooa7w5" updated="20230515190114">vector：可变大小数组</p>
<p id="20230515190114-eypvb5w" updated="20230515190114"><span data-type="strong" style="color: var(--b3-font-color11);">支持快速随机访问，在尾部以外位置删除/插入可能很慢</span></p>
</li>
<li id="20230515190114-j989iai" updated="20230515190114">
<p id="20230515190114-3uhqlrg" updated="20230515190114">deque：双端队列</p>
<p id="20230515190114-0uy1s5z" updated="20230515190114"><span data-type="strong" style="color: var(--b3-font-color11);">支持快速随机访问，在头尾位置插入/删除速度很快</span></p>
</li>
<li id="20230515190114-1frn2ko" updated="20230515190114">
<p id="20230515190114-zdky4ht" updated="20230515190114">list：双向链表</p>
<p id="20230515190114-z2axwrl" updated="20230515190114"><span data-type="strong" style="color: var(--b3-font-color11);">只支持双向随机访问，任何位置插入/删除都很快</span></p>
</li>
<li id="20230515190114-h0ns09p" updated="20230515190114">
<p id="20230515190114-5ug7iy2" updated="20230515190114">forward_list：单向链表</p>
<p id="20230515190114-lijyy9d" updated="20230515190114"><span data-type="strong" style="color: var(--b3-font-color11);">只支持单向顺序访问，任何位置插入/删除都很快</span></p>
</li>
<li id="20230515190114-ckx8le6" updated="20230515190114">
<p id="20230515190114-10uzo1i" updated="20230515190114">array：固定大小数组</p>
<p id="20230515190114-5iwu9ta" updated="20230515190114"><span data-type="strong" style="color: var(--b3-font-color11);">支持快速随机访问，不能添加/删除元素</span></p>
</li>
<li id="20230515190114-japbrb7" updated="20230515190114">
<p id="20230515190114-phrvzk5" updated="20230515190114">string：与vector相似，但是专门用来保存字符串</p>
<p id="20230515190114-y6qcrw2" updated="20230515190114"><span data-type="strong" style="color: var(--b3-font-color11);">支持快速随机访问，在尾部插入/删除速度快</span></p>
</li>
</ul>
<hr />
<p id="20230515190114-8gk006a" updated="20230515190114"><span data-type="strong" parent-style="text-align: center;">通常vector都是最好的选择</span></p>
<p id="20230515190114-6hbcw8t" updated="20230515190114"><span data-type="strong" parent-style="text-align: center;">不确定该使用哪种容器，那么可以只使用公共操作：使用迭代器而非下标，避免随机访问</span></p>
<h2 id="容器库概览" updated="20230515190114">容器库概览</h2>
<pre class="code-block" data-language="cpp"><code class="hljs">//假定noDefault是一个没有默认构造函数的类型
vector&lt;noDefault&gt; v1(10,int);        //正确
vector&lt;noDefault&gt; v2(10);            //错误，必须提供一个元素初始化器
</code></pre>
<hr />
<table id="20230515190114-9fn9g5w" updated="20230515190114">
<thead>
<tr>
<th align="center">操作</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">a.swap(b)</td>
<td align="center">交换a和b的元素</td>
</tr>
<tr>
<td align="center">swap(a,b)</td>
<td align="center">同上</td>
</tr>
<tr>
<td align="center">c.size（）</td>
<td align="center">c中元素的个数</td>
</tr>
<tr>
<td align="center">c.max_size( )</td>
<td align="center">c中可保存的最大元素数目<br /></td>
</tr>
<tr>
<td align="center">c.empty（）</td>
<td align="center">c中存储了元素为false，否则为true</td>
</tr>
<tr>
<td align="center">c.insert(args)</td>
<td align="center">将args中的元素拷贝进c</td>
</tr>
<tr>
<td align="center">c.clear（）</td>
<td align="center">删除c中所有元素，返回void</td>
</tr>
</tbody>
</table>
<p id="20230515190114-2ngxecy" updated="20230515190114"><span data-type="strong" style="color: var(--b3-font-color6);" parent-style="text-align: center;">添加或删除元素的操作不适用于array</span></p>
<hr />
<h3 id="迭代器" updated="20230515190114">迭代器</h3>
<h4 id="迭代器范围" updated="20230515190114">迭代器范围</h4>
<p id="20230515190114-ms9qfge" updated="20230515190114">一个迭代器范围由一对迭代器表示，两个迭代器分别指向同一个容器中的元素或是尾元素之后的位置，且end不在begin之前。</p>
<h4 id="反向迭代器" updated="20230515190114">反向迭代器</h4>
<p id="20230515190114-f1cybin" updated="20230515190114"><span data-type="strong" style="color: var(--b3-font-color12);">反向遍历容器，++得到上一个元素。</span>rbegin指向首元素之前位置。</p>
<pre class="code-block" data-language="cpp"><code class="hljs">vector&lt;int&gt; test;
for(auto it=test.rend();it!=rbegin();++it)//反向迭代器
{
//****
}
</code></pre>
<h3 id="begin和end成员" updated="20230515190114">begin和end成员</h3>
<pre class="code-block" data-language="cpp"><code class="hljs">vector&lt;int&gt; test;
test.begin();test.end();//……
test.rbegin();test.rend();//反向迭代器
test.cbegin();test.cend();//返回const版本
test.crbegin();test.crend();//返回const版本的反向迭代器
</code></pre>
<p id="20230515190114-4ijhhd1" updated="20230515190114">当不需要写访问时，应该使用cbegin和cend</p>
<h3 id="容器定义和初始化" updated="20230515190114">容器定义和初始化</h3>
<p id="20230515190114-htv12ff" updated="20230515190114"><span data-type="strong" style="color: var(--b3-font-color12);">除array之外，其他容器得默认构造函数都会创建一个指定类型的空容器，且都可以接受指定容器大小和元素初始值的参数。</span></p>
<h4 id="将容器初始化为另一个容器的拷贝" updated="20230515190114">将容器初始化为另一个容器的拷贝</h4>
<ul id="20230515190114-ho7l38n" updated="20230515190114">
<li id="20230515190114-hg17odq" updated="20230515190114">
<p id="20230515190114-tsfu306" updated="20230515190114">直接拷贝整个容器<span data-type="strong">*</span></p>
</li>
<li id="20230515190114-e1ho0th" updated="20230515190114">
<p id="20230515190114-5xe3fxg" updated="20230515190114">拷贝由另一个迭代器指定的元素范围（array除外）</p>
</li>
</ul>
<p id="20230515190114-n0ltlyq" updated="20230515190114"><span data-type="strong" parent-style="color: var(--b3-card-warning-color); background-color: var(--b3-card-warning-background);">*</span>此时两个容器的类型及其元素类型都必须匹配</p>
<pre class="code-block" data-language="cpp"><code class="hljs">list&lt;string&gt; au={&quot;give&quot;,&quot;a&quot;,&quot;test&quot;};
vector&lt;const char*&gt; ar={&quot;other&quot;,&quot;tests&quot;};

list&lt;string&gt; test1(au);//正确
deque&lt;string&gt; test2(au);//错误，容器类型不匹配
vector&lt;string&gt; test3(ar);//错误，元素类型不匹配
forward_list&lt;string&gt; test4(ar.begin(),ar.end());//正确，可以将const char*转化为string
</code></pre>
<h4 id="列表初始化" updated="20230515190114">列表初始化</h4>
<pre class="code-block" data-language="cpp"><code class="hljs">list&lt;string&gt; au={&quot;give&quot;,&quot;a&quot;,&quot;test&quot;};
vector&lt;const char*&gt; ar={&quot;other&quot;,&quot;tests&quot;};
</code></pre>
<h4 id="与顺序容器大小相关的构造函数" updated="20230515190114">与顺序容器大小相关的构造函数</h4>
<pre class="code-block" data-language="cpp"><code class="hljs">vector&lt;int&gt; ivec(10,-1);//10个int元素，每个都初始化为-1
deque&lt;string&gt; svec(10);//10个元素，每个都是空string
</code></pre>
<p id="20230515190114-q2wsfas" updated="20230515190114">只有顺序容器的构造函数才接受大小参数，关联容器并不支持</p>
<p id="20230515190114-454wbn6" updated="20230515190114">array必须同时指定元素类型和大小</p>
<h3 id="赋值和swap" updated="20230515190114">赋值和swap</h3>
<p id="20230515190114-bc5v1ny" updated="20230515190114">‍</p>
</div>
<script src="appearance/icons/material/icon.js?2.8.7"></script>
<script src="stage/build/export/protyle-method.js?2.8.7"></script>
<script src="stage/protyle/js/lute/lute.min.js?2.8.7"></script>    
<script>
    window.siyuan = {
      config: {
        appearance: { mode: 0, codeBlockThemeDark: "base16/dracula", codeBlockThemeLight: "github" },
        editor: { 
          codeLineWrap: true,
          codeLigatures: false,
          plantUMLServePath: "https://www.plantuml.com/plantuml/svg/~1",
          codeSyntaxHighlightLineNum: true,
          katexMacros: JSON.stringify({}),
        }
      },
      languages: {copy:"复制"}
    };
    const previewElement = document.getElementById('preview');
    Protyle.highlightRender(previewElement, "stage/protyle");
    Protyle.mathRender(previewElement, "stage/protyle", false);
    Protyle.mermaidRender(previewElement, "stage/protyle");
    Protyle.flowchartRender(previewElement, "stage/protyle");
    Protyle.graphvizRender(previewElement, "stage/protyle");
    Protyle.chartRender(previewElement, "stage/protyle");
    Protyle.mindmapRender(previewElement, "stage/protyle");
    Protyle.abcRender(previewElement, "stage/protyle");
    Protyle.plantumlRender(previewElement, "stage/protyle");
    document.querySelectorAll(".protyle-action__copy").forEach((item) => {
      item.addEventListener("click", (event) => {
            navigator.clipboard.writeText(item.parentElement.nextElementSibling.textContent.trimEnd());
            event.preventDefault();
            event.stopPropagation();
      })
    });
</script></body></html>